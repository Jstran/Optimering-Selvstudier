---
title: "Optimisation: Self study 3 -- Numerical differentiation"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
printf <- function(...) cat(sprintf(...))
printfln <- function(...) cat(sprintf(...), "\n")
library(microbenchmark)
```

# Sample problems

Use the problems below in the exercises.

```{r}
# analytic derivatives
H = function(x) 0.5*rbind(c(200, 0), c(0, 2))
```

# Exercise 1: BFGS, DFP and SR1

***
Implement BFGS, DFP and SR1 (as line search).

***
```{r}
# Implementation af backtracking
backtracking_line_search <- function(alpha, c, rho, x_k, p_k, g_k, f) {
	alpha_k <- alpha
	repeat { 
		lhs <- f(x_k + alpha_k * p_k)
		rhs <- f(x_k) + c * alpha_k * g_k %*% p_k
		if (lhs <= rhs) break
		alpha_k <- rho * alpha_k
	}
	return(alpha_k)
}

# Implementation af BFGS
BFGS <- function(f, g, x_k, alpha, c, rho, tol, k_max){
  k <- 0
  n <- length(x_k)
  H_k <- I_n <- diag(n)
  g_k <- tol + 1
  while (norm(g_k, type="2") > tol & k < k_max) {
    g_k <- g(x_k)
    p_k <- -  H_k %*% g_k
    alpha_k <- backtracking_line_search(alpha, c, rho, x_k, p_k, g_k, f)
    x_k <- x_k + alpha_k * p_k
    s_k <- alpha_k * p_k
    y_k <- g(x_k) - g_k
    rho_k <- 1 / (t(y_k) %*% s_k)[1]
    H_k <- (I_n - rho_k * (s_k %*% t(y_k))[1]) %*% H_k %*% (I_n - rho_k * (s_k %*% t(y_k))[1]) + rho_k * (s_k %*% t(s_k))[1]
    k <- k + 1
  }
  sol <- list(par = x_k , func = f(x_k) , grad = g_k , iter = k)
  return(sol)
}

# Implementation af BFGS opdatering
BFGS_620 <- function(f, g, x_k, alpha, c, rho, tol, k_max){
  n <- length(x_k)
  H_k <- I_n <- diag(n)
  g_k <- g(x_k)
    p_k <- -  H_k %*% g_k
    alpha_k <- backtracking_line_search(alpha, c, rho, x_k, p_k, g_k, f)
    x_k <- x_k + alpha_k * p_k
    s_k <- alpha_k * p_k
    y_k <- g(x_k) - g_k
    H_k <- ((t(y_k) %*% s_k)[1]) / ((t(y_k) %*% y_k)[1]) * I_n
    k <- 1
  while (norm(g_k, type="2") > tol & k < k_max) {
    g_k <- g(x_k)
    p_k <- -  H_k %*% g_k
    alpha_k <- backtracking_line_search(alpha, c, rho, x_k, p_k, g_k, f)
    x_k <- x_k + alpha_k * p_k
    s_k <- alpha_k * p_k
    y_k <- g(x_k) - g_k
    rho_k <- 1 / (t(y_k) %*% s_k)[1]
    H_k <- (I_n - rho_k * (s_k %*% t(y_k))[1]) %*% H_k %*% (I_n - rho_k * (s_k %*% t(y_k))[1]) + rho_k * (s_k %*% t(s_k))[1]
    k <- k + 1
  }
sol <- list(par = x_k , func = f(x_k) , grad = g_k , iter = k)
  return(sol)
}

# Implementation af DFP
DFP <- function(f, g, x_k, alpha, c, rho, tol, k_max){
  k <- 0
  n <- length(x_k)
  H_k <- I_n <- diag(n)
  g_k <- tol + 1
  while (norm(g_k, type="2") > tol & k < k_max) {
    g_k <- g(x_k)
    p_k <- -  H_k %*% g_k
    alpha_k <- backtracking_line_search(alpha, c, rho, x_k, p_k, g_k, f)
   x_k <- x_k + alpha_k * p_k
    s_k <- alpha_k * p_k
    y_k <- g(x_k) - g_k
    H_k <- H_k - (H_k %*% y_k %*% t(y_k) %*% H_k) / (t(y_k) %*% H_k %*% y_k)[1] + (s_k %*% t(s_k)) / (t(y_k) %*% s_k)[1]
    k <- k + 1
  }
  sol <- list(par = x_k , func = f(x_k) , grad = g_k , iter = k)
  return(sol)
}

```


Undersøger antal iteration for de forskellige metoder. Der benyttes funktionen
$$f(x_1,x_2) = \frac{1}{2}(100x_1^2+x_2^2),$$ hvor funktionens gradient er udregnet i hånden til at være
$$\nabla f(x_1,x_2) = \begin{pmatrix}100x_1 \\ x_2\end{pmatrix}.$$
```{r}
f = function(x) 0.5*(100*x[1]^2 + x[2]^2)
g = function(x) c(100*x[1], x[2])

x_k <- c(5,1) # Valgt startværdi
alpha <- 1    
c <- 1e-4
tol <- 1e-4
rho <- 0.5
k_max <- 10000


DFP(f, g, x_k, alpha, c, rho, tol, k_max)$par
BFGS(f, g, x_k, alpha, c, rho, tol, k_max)$par
BFGS_620(f, g, x_k, alpha, c, rho, tol, k_max)$par
optim(x_k, f, g, method = "BFGS")$par
```
***
Compare those with the gradient descent, Nelder-Mead (possibly by `optim(..., method = "Nelder-Mead")`) and `R`'s own BFGS implementation (`optim(..., method = "BFGS")`) on the problems given above: What are the differences? What is the performance difference (number of iterations, execution time e.g. `system.time`)? What impact does the choice of initial matrix (and possibly using (6.20)) have on the quasi-Newton methods?

Remember the DRY principle (don't repeat yourself). Here is a example of how to plot several lines in a figure:

***
```{r}
res_bfgs <- cumprod(runif(10))
res_dfp <- cumprod(runif(10))
res_sr1 <- cumprod(runif(10))

nms <- c("BFGS", "DFP", "SR1")
clrs <- c("black", "red", "blue")
x_plot <- list(res_bfgs, res_dfp, res_sr1)

x_lim <- c(1, max(sapply(x_plot, length)))
y_lim <- range(sapply(x_plot, range))

plot(seq_along(x_plot[[1]]), x_plot[[1]], 
     type = "l", col = clrs[1], 
     xlim = x_lim, ylim = y_lim,
     xlab = "Iteration",
     ylab = "Some value")
for (i in 2L:length(x_plot)) {
  lines(seq_along(x_plot[[i]]), x_plot[[i]], col = clrs[i])
}
legend("topright", legend = nms, col = clrs, lty = 1)
```

```{r}
steepest_descent <- function(f, g, x_k, alpha, c, rho, tol, k_max) {
  k <- 0
	g_k <- tol + 1 # For at komme i gang
	
	while ((norm(g_k,type="2") > tol) & (k < k_max)) { # Type 2 er for vektorer
		g_k <- g(x_k)
		p_k <- -g_k 
		alpha_k <- backtracking_line_search(alpha , c, rho, x_k, p_k, g_k, f)
		x_k <- x_k + alpha_k * p_k
		k <- k + 1
	}
	sol <- list(par = x_k , func = f(x_k) , grad = g_k , iter = k)
	return(sol)
}

microbenchmark(
optim(x_k, f, g, method = "BFGS") ,
optim(x_k, f,    method = "Nelder-Mead") ,
DFP(f, g, x_k, alpha, c, rho, tol, k_max) ,
steepest_descent(f, g, x_k, alpha, c, rho, tol, k_max) ,
BFGS(f, g, x_k, alpha, c, rho, tol, k_max) , 
BFGS_620(f, g, x_k, alpha, c, rho, tol, k_max) ,
unit = "ms"
)
```

# Exercise 2: Inverse Hessian approximations

Investigate (plot, print, ...) the approximations of the Hessian ($B_{k}^{BFGS}$, $B_{k}^{DFP}$, and $B_{SR1}$) and inverse Hessian ($H_{k}^{BFGS}$, $H_{k}^{DFP}$, and $H_{SR1}$) in the optimisation problems given above. Compare to the the exact Hessian (and inverse) and maybe also to approximations by finite differences and/or automatic differentiation (possibly by libraries `numDeriv`/`madness`). (How can you summarise the difference on matrices?)

# Exercise 3: Self-correcting properties

What happens if you introduce error in the $H_k$'s in the implementations of BFGS, DFP, and SR1? Will the method self-correct? (Discuss how to introduce error.)

Compare to methods without this error and the true inverse Hessian.


# Exercise 4: Be creative!

If you have anything, put it here.