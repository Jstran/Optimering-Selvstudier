---
title: "Optimisation: Self study 3 -- Numerical differentiation"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
printf <- function(...) cat(sprintf(...))
printfln <- function(...) cat(sprintf(...), "\n")
```

# Sample problems

Use the problems below in the exercises.

```{r}
###########################################
# Rosenbrock Objective Function
###########################################
f = function(x) 100*(x[2] - x[1]^2)^2 + (1 - x[1])^2
f_xy = function(x, y) 100*(y - x^2)^2 + (1 - x)^2
x_min_true = c(1, 1)

# analytic derivatives
g = function(x) c(2*(x[1] - 1) - 400*x[1]*(x[2] - x[1]^2), 200*(x[2] - x[1]^2))
H = function(x) rbind(c(1200*x[1]^2 - 400*x[2] + 2, -400*x[1]), c(-400*x[1], 200))

###########################################
# Convex Elliptical Objective Function
###########################################
f = function(x) 0.5*(100*x[1]^2 + x[2]^2)
f_xy = function(x,y) 0.5*(100*x^2 + y^2)
x_min_true = c(0, 0)

# analytic derivatives
g = function(x) c(0.5*200*x[1], 0.5*2*x[2])
H = function(x) 0.5*rbind(c(200, 0), c(0, 2))

###########################################
# Nonconvex Sines Objective Function
###########################################
'f = function(x) x[1]^2 + .25*x[2]^2 + 4*(x[1] - x[2])^2*sin(x[2])^2
f_xy = function(x, y) x^2 + .25*y^2 + 4*(x - y)^2*sin(y)^2
x_min_true = c(0, 0)

# analytic derivatives
g = function(x) c(2*x[1] + 8*(x[1] - x[2])*sin(x[2])^2, .5*x[2] - 8*(x[1] - x[2])*sin(x[2])^2 + 4*(x[1] - x[2])^2*sin(2*x[2]))
H = function(x)
{
	H11 = 2 + 8*sin(x[2])^2
	H12 = 8*(2*(x[1] - x[2])*cos(x[2]) - sin(x[2]))*sin(x[2])
	H21 = H12
	H22 = 4.5 + 4*(2*(x[1] - x[2])^2 - 1)*cos(2*x[2]) + 16*(x[2] - x[1])*sin(2*x[2])
	rbind(c(H11, H12), c(H21, H22))
}'
```

# Exercise 1: BFGS, DFP and SR1

Implement BFGS, DFP and SR1 (as line search).
```{r}
# Definerer lige noget line-search (Der er Wolfe i)
backtracking_line_search <- function(alpha, c, rho, x_k, p_k, g_k, f) {
	alpha_k <- alpha
	repeat { 
		lhs <- f(x_k + alpha_k * p_k)
		rhs <- f(x_k) + c * alpha_k * g_k %*% p_k
		if (lhs <= rhs) break
		alpha_k <- rho * alpha_k
	}
	return(alpha_k)
}

# Implementation af BFGS
BFGS <- function(f, g, x_k, alpha, c, rho, tol, k_max){
  k <- 0
  n <- length(x_k)
  H_k <- I_n <- diag(n)
  g_k <- tol + 1
  while (norm(g_k, type="2") > tol & k < k_max) {
    g_k <- g(x_k)
    f_k <- f(x_k)
    p_k <- -  H_k %*% g_k
    alpha_k <- backtracking_line_search(alpha, c, rho, x_k, p_k, g_k, f)
    x_old <- x_k
    x_k <- x_k + alpha_k * p_k
    s_k <- x_k - x_old
    y_k <- g(x_k) - g_k
    rho_k <- 1 / (t(y_k) %*% s_k)[1]
    H_k <- (I_n - rho_k * (s_k %*% t(y_k))[1]) %*% H_k %*% (I_n - rho_k * (s_k %*% t(y_k))[1]) + rho_k * (s_k %*% t(s_k))[1]
    k <- k + 1
  }
printfln("k = %d \t x_k = (%6.3f , %6.3f) \t f_k = %.2f \t g_k = (%8.3f , %8.3f) \t alpha_k = %.5f", k, x_k[1] , x_k[2], f(x_k), g_k[1] , g_k[2], alpha_k)
  return(x_k)
}

# Implementation af DFP
DFP <- function(f, g, x_k, alpha, c, rho, tol, k_max){
  k <- 0
  n <- length(x_k)
  H_k <- I_n <- diag(n)
  g_k <- tol + 1
  while (norm(g_k, type="2") > tol & k < k_max) {
    g_k <- g(x_k)
    f_k <- f(x_k)
    p_k <- -  H_k %*% g_k
    alpha_k <- backtracking_line_search(alpha, c, rho, x_k, p_k, g_k, f)
    x_old <- x_k
    x_k <- x_k + alpha_k * p_k
    s_k <- x_k - x_old
    y_k <- g(x_k) - g_k
    H_k <- H_k - (H_k %*% y_k %*% t(y_k) %*% H_k) / (t(y_k) %*% H_k %*% y_k)[1] + (s_k %*% t(s_k)) / (t(y_k) %*% s_k)[1]
    k <- k + 1
  }
printfln("k = %d \t x_k = (%6.3f , %6.3f) \t f_k = %.2f \t g_k = (%8.3f , %8.3f) \t alpha_k = %.5f", k, x_k[1] , x_k[2], f(x_k), g_k[1] , g_k[2], alpha_k)
  return(x_k)
}


```



```{r}
x_k <- c(5,5)
alpha <- 1
c <- 1e-4
tol <- 1e-8
rho <- 0.5
k_max <- 100000

DFP(f, g, x_k, alpha, c, rho, tol, k_max)
BFGS(f, g, x_k, alpha, c, rho, tol, k_max)
optim(x_k, f, g, method = "BFGS")
```
Compare those with the gradient descent, Nelder-Mead (possibly by `optim(..., method = "Nelder-Mead")`) and `R`'s own BFGS implementation (`optim(..., method = "BFGS")`) on the problems given above: What are the differences? What is the performance difference (number of iterations, execution time e.g. `system.time`)? What impact does the choice of initial matrix (and possibly using (6.20)) have on the quasi-Newton methods?

Remember the DRY principle (don't repeat yourself). Here is a example of how to plot several lines in a figure:

```{r}
res_bfgs <- cumprod(runif(10))
res_dfp <- cumprod(runif(10))
res_sr1 <- cumprod(runif(10))

nms <- c("BFGS", "DFP", "SR1")
clrs <- c("black", "red", "blue")
x_plot <- list(res_bfgs, res_dfp, res_sr1)

x_lim <- c(1, max(sapply(x_plot, length)))
y_lim <- range(sapply(x_plot, range))

plot(seq_along(x_plot[[1]]), x_plot[[1]], 
     type = "l", col = clrs[1], 
     xlim = x_lim, ylim = y_lim,
     xlab = "Iteration",
     ylab = "Some value")
for (i in 2L:length(x_plot)) {
  lines(seq_along(x_plot[[i]]), x_plot[[i]], col = clrs[i])
}
legend("topright", legend = nms, col = clrs, lty = 1)
```
```{r}

```

# Exercise 2: Inverse Hessian approximations

Investigate (plot, print, ...) the approximations of the Hessian ($B_{k}^{BFGS}$, $B_{k}^{DFP}$, and $B_{SR1}$) and inverse Hessian ($H_{k}^{BFGS}$, $H_{k}^{DFP}$, and $H_{SR1}$) in the optimisation problems given above. Compare to the the exact Hessian (and inverse) and maybe also to approximations by finite differences and/or automatic differentiation (possibly by libraries `numDeriv`/`madness`). (How can you summarise the difference on matrices?)

# Exercise 3: Self-correcting properties

What happens if you introduce error in the $H_k$'s in the implementations of BFGS, DFP, and SR1? Will the method self-correct? (Discuss how to introduce error.)

Compare to methods without this error and the true inverse Hessian.


# Exercise 4: Be creative!

If you have anything, put it here.